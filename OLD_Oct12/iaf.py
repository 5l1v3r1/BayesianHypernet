# -*- coding: utf-8 -*-
"""
Created on Fri Sep 15 18:09:12 2017

@author: Chin-Wei

inverse autoregressive flows
"""




import theano
import theano.tensor as T
import numpy as np
from externals_modules.made_modules import MADE

delta = 1e-6
linear = lambda x: x
softplus = lambda x: T.nnet.softplus(x) + delta


def lse(a,b,wa=1,wb=1, sum_op=T.sum):
    
        A_max = T.maximum(a,b)
        return T.log(wa*T.exp(a-A_max) + wb*T.exp(b-A_max)) + A_max


def get_wn_params(P,name,d1,d2):
    P['u_{}'.format(name)] = np.random.normal(0,1e-4,(d1,d2))        
    P['g_{}'.format(name)] = np.random.normal(0,1e-4,(d2,))     
    P['b_{}'.format(name)] = np.zeros((d2,))        


def weightnorm(W_,g):
    if W_.ndim==4:
        W_axes_to_sum = (1,2,3)
        W_dimshuffle_args = [0,'x','x','x']
    else:
        W_axes_to_sum = 0
        W_dimshuffle_args = ['x',0]
        
    norm = T.sqrt(T.sum(T.square(W_),axis=W_axes_to_sum,keepdims=True))
    W_normed = W_ / norm
    return W_normed * g.dimshuffle(*W_dimshuffle_args)

    
def dot_():
    dot = lambda X,W,b: T.dot(X,W) + b.dimshuffle('x',0)
    return dot

    
def weightnormdot(X,W,g,b,operator=dot_(),nonl=None):
    h = operator(X,weightnorm(W,g),b)
    if nonl is not None:
        return nonl(h)
    else:
        return h
        

def iaf_made_wn(P=None,
                name='iaf',
                K=2,
                L=1,
                num_units=10,
                num_hids=1,
                nonl=T.nnet.relu,
                cond_bias=False):
    
    aux_input = T.matrix()
    masks = list()      
    for l in range(L):
        made = MADE(aux_input,K,
                    hidden_sizes=[num_units,]*num_hids,
                    hidden_activation=nonl,
                    random_seed=1234+l)
        
        
        made.shuffle('Once')
        made.shuffle('Full')
        
        # saving the masks generated by `MADE`
        masks.append([m.get_value() for m in made.masks])
        # initializing parameters, 
        # # last one is mean
        for h,m in enumerate(masks[l]):
            d1,d2 = m.shape
            get_wn_params(P,'{}_l{}h{}'.format(name,l,h),d1,d2)
        # # std
        get_wn_params(P,'{}_l{}h{}s'.format(name,l,h),d1,d2)
        # # additional conditional bias
        if cond_bias:
            d1,d2 = masks[l][0]
            get_wn_params(P,'{}_l{}cb1'.format(name,l),d1,d2)
            if l != L-1:
                get_wn_params(P,'{}_l{}cb2'.format(name,l),d1,d2)
        
    def iaf(z0,cond_bias=None):
            
        zs = list()
        zs.append(z0)
        ss = T.zeros((z0.shape[0],)) # logdet jacobian
        
        for l in range(L):
            hidden = zs[l]
            for h in range(num_hids+1):
                mask = masks[l][h]
                u = P['u_{}_l{}h{}'.format(name,l,h)]
                g = P['g_{}_l{}h{}'.format(name,l,h)]
                b = P['b_{}_l{}h{}'.format(name,l,h)]
                u_ = T.switch(mask,u,0)
                if h != num_hids:
                    hidden = weightnormdot(hidden,u_,g,b,nonl=nonl)
                else:
                    mean = weightnormdot(hidden,u_,g,b,nonl=None)
            
                if h == 0 and cond_bias is not None:
                    u = P['u_{}_l{}cb1'.format(name,l,h)]
                    g = P['g_{}_l{}cb1'.format(name,l,h)]
                    b = P['b_{}_l{}cb1'.format(name,l,h)]
                    hidden_cb = weightnormdot(cond_bias,u,g,b,nonl=nonl)
                    hidden += hidden_cb
                    if l != L-1:
                        u = P['u_{}_l{}cb2'.format(name,l,h)]
                        g = P['g_{}_l{}cb2'.format(name,l,h)]
                        b = P['b_{}_l{}cb2'.format(name,l,h)]
                        cond_bias = weightnormdot(hidden_cb,u,g,b,nonl=nonl)
                        
            
            u = P['u_{}_l{}h{}s'.format(name,l,h)]
            g = P['g_{}_l{}h{}s'.format(name,l,h)]
            b = P['b_{}_l{}h{}s'.format(name,l,h)]
            u_ = T.switch(mask,u,0)
            std = weightnormdot(hidden,u_,g,b,nonl=softplus)
            
            z = mean + std * zs[l]
            zs.append(z)
            ss += T.sum(T.log(std),1)
        
        return z, ss
        
    return iaf, masks
    
    
if 1:

    """
    an example of using invertible transformation to fit a complicated 
    density function that is hard to sample from
    """       
    
    
    def U(Z):
        # log density of unnormalized distribution
        z1 = Z[:, 0]
        z2 = Z[:, 1]
        w1 = T.sin(2.*np.pi*z1/5.)
        w3 = 3. * T.nnet.sigmoid((z1-1.)/0.3)
        w4 = T.abs_(z1)
        
        B1 = -0.5*(((z2-w1)/0.4)**2) - 0.1 * w4
        B2 = -0.5*(((z2-w1+w3)/0.35)**2) - 0.1 * w4
        B3 = -0.5*(z1**2 + z2**2/5.)
        return lse(lse(B1,B2),B3)
    
    
    from theano_toolkit.parameters import Parameters
    from theano_toolkit import updates
    from pprint import pprint
    floatX = theano.config.floatX


    print 'building model'
    z0 = T.matrix('z0')    
    P = Parameters() 
    iaf, masks = iaf_made_wn(P,L=8,num_units=64,
                             num_hids=1,nonl=T.nnet.elu,
                             cond_bias=False)
    zT, ss = iaf(z0,cond_bias=None)
    parameters = P.values()
    pprint(parameters)
    

    logp = U(zT)
    logq = - ss
    losses = logq - logp
    loss = losses.mean()
    gradients = updates.clip_deltas(T.grad(loss, wrt=parameters), 5)    
    P_train = Parameters()    
    fupdates = updates.adam(parameters, gradients,
                            learning_rate=1e-3, P=P_train)
    
    train = theano.function([z0],[loss,logq.mean(),logp.mean()],
                            updates=fupdates)
    samples = theano.function([z0],zT)
    
    gradoldold = 0 # for debugging
    gradold = 0
    print 'starting training'
    for i in range(50000):
        spl = np.random.randn(64,2).astype(floatX)
        outs = train(spl)
        l = outs[0]
        lq = outs[1]
        lp = outs[2]
        gs = outs[2:]
        gradoldold = gradold
        gradold = [gs,l,lq,lp]
        
        if np.isnan(l):
            raise Exception
        if i%1000==0:
            print l
    
    print "\nvisualizing"
    density = U(z0)
    f0 = theano.function([z0],density)
    
    import matplotlib.pyplot as plt
    fig = plt.figure()
    x1,x2,y1,y2 = -10,10,-10,10
    
    ax = fig.add_subplot(1,2,1)
    x = np.linspace(x1,x2,1000)
    y = np.linspace(y1,y2,1000)
    xx,yy = np.meshgrid(x,y)
    X = np.concatenate((xx.reshape(1000000,1),yy.reshape(1000000,1)),1)
    X = X.astype(floatX)
    Z = f0(X).reshape(1000,1000)
    ax.pcolormesh(xx,yy,np.exp(Z))
    ax.axis('off')
    plt.xlim((x1,x2))
    plt.ylim((y1,y2))
    
    ax = fig.add_subplot(1,2,2)
    Z0 = spl = np.random.randn(200000,2).astype(floatX)
    Zs = samples(Z0)
    XX = Zs[:,0]
    YY = Zs[:,1]
    plot = ax.hist2d(XX,YY,200,range=np.array([(x1, x2), (y1, y2)]))
    plt.xlim((x1,x2))
    plt.ylim((y1,y2))
    plt.axis('off')



